// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createName = `-- name: CreateName :one
INSERT INTO name(user_id, first_name, middle_name, last_name)
VALUES ($1, $2, $3, $4)
RETURNING user_id, first_name, middle_name, last_name
`

type CreateNameParams struct {
	UserID     uuid.UUID
	FirstName  string
	MiddleName string
	LastName   string
}

func (q *Queries) CreateName(ctx context.Context, arg CreateNameParams) (Name, error) {
	row := q.db.QueryRow(ctx, createName,
		arg.UserID,
		arg.FirstName,
		arg.MiddleName,
		arg.LastName,
	)
	var i Name
	err := row.Scan(
		&i.UserID,
		&i.FirstName,
		&i.MiddleName,
		&i.LastName,
	)
	return i, err
}

const createPhone = `-- name: CreatePhone :one
INSERT INTO phone_number(phone_number, user_id)
VALUES ($1, $2)
RETURNING phone_number, user_id
`

type CreatePhoneParams struct {
	PhoneNumber string
	UserID      pgtype.UUID
}

func (q *Queries) CreatePhone(ctx context.Context, arg CreatePhoneParams) (PhoneNumber, error) {
	row := q.db.QueryRow(ctx, createPhone, arg.PhoneNumber, arg.UserID)
	var i PhoneNumber
	err := row.Scan(&i.PhoneNumber, &i.UserID)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO "user"(user_id, password_hash, user_type)
VALUES ($1, $2, $3)
RETURNING user_id, password_hash, is_active, user_type
`

type CreateUserParams struct {
	UserID       uuid.UUID
	PasswordHash string
	UserType     string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.UserID, arg.PasswordHash, arg.UserType)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.PasswordHash,
		&i.IsActive,
		&i.UserType,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT user_id, password_hash, is_active, user_type from "user"
WHERE user_id = $1
`

func (q *Queries) GetUser(ctx context.Context, userID uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUser, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.PasswordHash,
		&i.IsActive,
		&i.UserType,
	)
	return i, err
}

const getUserIDByPhone = `-- name: GetUserIDByPhone :one
SELECT user_id
FROM phone_number
WHERE phone_number.phone_number = $1
`

func (q *Queries) GetUserIDByPhone(ctx context.Context, phoneNumber string) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getUserIDByPhone, phoneNumber)
	var user_id pgtype.UUID
	err := row.Scan(&user_id)
	return user_id, err
}

const phoneExists = `-- name: PhoneExists :one
SELECT TRUE
FROM phone_number
WHERE phone_number = $1
`

func (q *Queries) PhoneExists(ctx context.Context, phoneNumber string) (bool, error) {
	row := q.db.QueryRow(ctx, phoneExists, phoneNumber)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}
